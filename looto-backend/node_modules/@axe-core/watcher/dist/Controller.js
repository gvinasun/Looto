"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readVariables_1 = __importDefault(require("./utils/readVariables"));
const sendResultsToServer_1 = __importDefault(require("./sendResultsToServer"));
const createDebugger_1 = __importDefault(require("./createDebugger"));
const assertVariablesWereWritten_1 = require("./utils/assertVariablesWereWritten");
const constants_1 = require("./utils/constants");
class Controller {
    constructor({ debugLoggerName, integrationName, configurationFunction }) {
        (0, assertVariablesWereWritten_1.assertVariablesWereWritten)(integrationName, configurationFunction);
        const variables = (0, readVariables_1.default)();
        this.axeCoreSettings = variables.axe_core_settings;
        this.runOptions = variables.run_options;
        this.isStopped = !variables?.auto_analyze;
        this.timeout = variables.timeout;
        this.debugLogger = (0, createDebugger_1.default)(debugLoggerName);
    }
    async start({ timeout } = {}) {
        this.debugLogger(`Start: Invoked`);
        let timer = null;
        await Promise.race([
            this.executeScript(() => {
                return new Promise(resolve => {
                    if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                        resolve({ message: 'Clean skipped - invalid protocol' });
                    }
                    if (window.top !== window.self) {
                        resolve({
                            message: 'Clean skipped - Unable to analyze, not in top-level frame'
                        });
                    }
                    const fn = (event) => {
                        window.removeEventListener('axe:manual-mode-clean-done', fn);
                        resolve({ message: event.detail.message });
                    };
                    window.addEventListener('axe:manual-mode-clean-done', fn);
                    const event = new CustomEvent('axe:manual-mode-clean');
                    window.dispatchEvent(event);
                });
            }),
            new Promise((_, reject) => {
                timer = setTimeout(() => {
                    reject(new Error(`Watcher could not start automatic mode because \`start\` timed out. To resolve this problem, increase the \`timeout.start\` property within your configuration or see ${constants_1.DOCS_LINK} for more troubleshooting.`));
                }, timeout || this.timeout.start);
            })
        ])
            .then(result => {
            this.debugLogger(`Start: ${result.message}`);
        })
            .finally(() => {
            if (timer) {
                clearTimeout(timer);
            }
            this.isStopped = false;
        });
    }
    async stop({ timeout } = {}) {
        this.debugLogger(`Stop: Invoked (${this.isStopped ? 'not analyzing' : 'may analyze implicitly'})`);
        if (this.isStopped) {
            return Promise.resolve();
        }
        let timer = null;
        await Promise.race([
            this.executeScript(() => {
                if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                    return Promise.resolve({ message: 'Skipped - Invalid protocol' });
                }
                if (window.top !== window.self) {
                    return Promise.resolve({
                        message: 'Skipped - Unable to analyze, not in top-level frame'
                    });
                }
                return new Promise(resolve => {
                    const fn = (event) => {
                        window.removeEventListener('axe:manual-mode-analyze-done', fn);
                        resolve(event.detail);
                    };
                    window.addEventListener('axe:manual-mode-analyze-done', fn);
                    const event = new CustomEvent('axe:manual-mode-analyze', {
                        detail: { userRequestedAnalyze: false }
                    });
                    window.dispatchEvent(event);
                });
            }),
            new Promise((_, reject) => {
                timer = setTimeout(() => {
                    reject(new Error(`Watcher could not stop automatic mode because \`stop\` timed out. To resolve this problem, increase the \`timeout.stop\` property within your configuration or see ${constants_1.DOCS_LINK} for more troubleshooting.`));
                }, timeout || this.timeout.stop);
            })
        ])
            .then(result => {
            this.debugLogger(`Stop: ${result.message}`);
        })
            .finally(() => {
            if (timer) {
                clearTimeout(timer);
            }
            this.isStopped = true;
        });
    }
    async analyze({ __Method, __UserRequestedAnalyze = true } = {}, { timeout } = {}) {
        this.debugLogger(`Analyze: Invoked${__Method ? ` - ${__Method}` : ''}`, {
            isStopped: this.isStopped,
            userRequestedAnalyze: __UserRequestedAnalyze
        });
        if (this.isStopped && !__UserRequestedAnalyze) {
            this.debugLogger('Analyze: Skipped', {
                isStopped: this.isStopped,
                userRequestedAnalyze: __UserRequestedAnalyze
            });
            return;
        }
        let timer = null;
        await Promise.race([
            this.executeScript(({ userRequestedAnalyze, isStopped, axeCoreSettings, runOptions }) => {
                if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                    if (userRequestedAnalyze) {
                        return Promise.resolve({
                            message: `Cannot perform analysis - invalid protocol: ${window.location.protocol}`,
                            error: true
                        });
                    }
                    return Promise.resolve({ message: 'Skipped - Invalid protocol' });
                }
                if (window.top !== window.self) {
                    return Promise.resolve({
                        message: 'Skipped - Unable to analyze, not in top-level frame'
                    });
                }
                return new Promise(resolve => {
                    const fn = (event) => {
                        window.removeEventListener('axe:manual-mode-analyze-done', fn);
                        resolve(event.detail);
                    };
                    window.addEventListener('axe:manual-mode-analyze-done', fn);
                    const event = new CustomEvent('axe:manual-mode-analyze', {
                        detail: {
                            userRequestedAnalyze,
                            isStopped,
                            axeCoreSettings,
                            runOptions
                        }
                    });
                    window.dispatchEvent(event);
                });
            }, {
                userRequestedAnalyze: __UserRequestedAnalyze,
                isStopped: this.isStopped,
                axeCoreSettings: this.axeCoreSettings,
                runOptions: this.runOptions
            }),
            new Promise((_, reject) => {
                timer = setTimeout(() => {
                    reject(new Error(`Watcher timed out before it could finish analyzing the page state. To resolve this problem, increase the \`timeout.analyze\` property within your configuration or see ${constants_1.DOCS_LINK} for more troubleshooting.`));
                }, timeout || this.timeout.analyze);
            })
        ])
            .then(result => {
            this.debugLogger(`Analyze: ${result.message}`);
            if (result.error) {
                throw new Error(result.message);
            }
        })
            .finally(() => {
            if (timer) {
                clearTimeout(timer);
            }
        });
    }
    async flush({ timeout } = {}) {
        this.debugLogger(`Flush: Invoked (${this.isStopped ? 'auto-analysis stopped' : 'may analyze implicitly'})`);
        let timer = null;
        await Promise.race([
            this.executeScript(({ isStopped, axeCoreSettings, runOptions }) => {
                if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                    return Promise.resolve([]);
                }
                if (window.top !== window.self) {
                    return Promise.resolve([]);
                }
                return new Promise(resolve => {
                    const receivedResults = [];
                    const onFlushEnd = () => {
                        window.removeEventListener('axe:flush-end', onFlushEnd);
                        window.removeEventListener('axe:result', onAxeResult);
                        resolve(receivedResults);
                    };
                    const onAxeResult = (e) => {
                        receivedResults.push(...e.detail);
                    };
                    window.addEventListener('axe:result', onAxeResult);
                    window.addEventListener('axe:flush-end', onFlushEnd);
                    const event = new CustomEvent('axe:flush-start', {
                        detail: {
                            isStopped,
                            axeCoreSettings,
                            runOptions
                        }
                    });
                    window.dispatchEvent(event);
                });
            }, {
                isStopped: this.isStopped,
                axeCoreSettings: this.axeCoreSettings,
                runOptions: this.runOptions
            }),
            new Promise((_, reject) => {
                timer = setTimeout(() => {
                    reject(new Error(`Watcher timed out sending results to the server. To resolve this problem, increase the \`timeout.flush\` property within your configuration or see ${constants_1.DOCS_LINK} for more troubleshooting.`));
                }, timeout || this.timeout.flush);
            })
        ])
            .then(async (results) => {
            this.debugLogger(`Flush: Received ${results.length} results`);
            await (0, sendResultsToServer_1.default)({
                results,
                debugLogger: this.debugLogger
            });
            this.debugLogger('Flush: Complete');
        })
            .finally(() => {
            if (timer) {
                clearTimeout(timer);
            }
        });
    }
}
exports.default = Controller;
//# sourceMappingURL=Controller.js.map