"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendResultsToServer = exports.MAX_RETRIES = exports.MAX_PAGE_STATES_PER_REQUEST = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const uuid_1 = require("uuid");
const readVariables_1 = __importDefault(require("./utils/readVariables"));
const linearBackoff_1 = __importDefault(require("./utils/linearBackoff"));
const { version } = require('../package.json');
exports.MAX_PAGE_STATES_PER_REQUEST = 5;
exports.MAX_RETRIES = 3;
const sendResultsToServer = async ({ results, debugLogger }) => {
    const { server_url, api_key, session_id, git_data } = (0, readVariables_1.default)();
    const resultsURL = new URL(`/api-pub/watcher/sessions/${session_id}`, server_url);
    const screenshotsURL = new URL(`/api-pub/watcher/sessions/${session_id}/screenshots`, server_url);
    debugLogger('SendResultsToServer: Received results', {
        total: results.length,
        totalBytes: Buffer.byteLength(JSON.stringify(results))
    });
    debugLogger('SendResultsToServer: Session ID', { session_id });
    const putResults = async (bodyResults = [], retryAttempt = 0) => {
        const body = {
            axe_watcher_version: version,
            results: bodyResults,
            ...git_data
        };
        const res = await (0, node_fetch_1.default)(resultsURL, {
            method: 'PUT',
            redirect: 'follow',
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': api_key
            },
            body: JSON.stringify(body)
        });
        if (!res.ok) {
            debugLogger('SendResultsToServer: Failed to send results', {
                batchResults: bodyResults.length,
                reqSize: Buffer.byteLength(JSON.stringify(body)),
                resStatus: res.status,
                resStatusText: res.statusText
            });
            console.warn('@axe-core/watcher: Unable to send results to server');
        }
        else {
            debugLogger('SendResultsToServer: Successfully sent', {
                batchResults: bodyResults.length,
                reqSize: Buffer.byteLength(JSON.stringify(body)),
                resStatus: res.status,
                resStatusText: res.statusText
            });
        }
        const is500 = res.status === 500;
        const is408 = res.status === 408;
        const is429 = res.status === 429;
        if ((is500 || is408 || is429) && retryAttempt !== exports.MAX_RETRIES) {
            const incrementRetry = retryAttempt + 1;
            console.warn('@axe-core/watcher: Retrying...');
            debugLogger('SendResultsToServer: Retrying...', {
                retryAttempt: incrementRetry,
                resStatus: res.status,
                batchResults: bodyResults.length,
                reqSize: Buffer.byteLength(JSON.stringify(body))
            });
            await (0, linearBackoff_1.default)(incrementRetry);
            await putResults(bodyResults, incrementRetry);
        }
        else if (retryAttempt === exports.MAX_RETRIES) {
            debugLogger('SendResultsToServer: Max retries reached', {
                retryAttempt,
                resStatus: res.status
            });
            console.warn('@axe-core/watcher: Unable to send results to server, max retries reached');
        }
    };
    results.forEach(result => {
        if (result.screenshot) {
            result.screenshot_id = (0, uuid_1.v4)();
        }
    });
    const requestErrorHandler = (error) => {
        debugLogger('SendResultsToServer: Fetch error', {
            message: error.message,
            type: error.type || 'NA',
            code: error.code || 'NA',
            stack: error.stack || 'NA',
            errno: error.errno || 'NA'
        });
    };
    for (let i = 0; i < results.length; i += exports.MAX_PAGE_STATES_PER_REQUEST) {
        const batch = results
            .slice(i, i + exports.MAX_PAGE_STATES_PER_REQUEST)
            .map(r => ({ ...r, screenshot: null }));
        await putResults(batch).catch(requestErrorHandler);
    }
    await Promise.all(results.map(async ({ screenshot, screenshot_id }) => {
        if (!screenshot) {
            return;
        }
        const url = new URL(screenshotsURL.href);
        url.searchParams.set('screenshot_id', screenshot_id);
        const { ok } = await (0, node_fetch_1.default)(url, {
            method: 'POST',
            redirect: 'follow',
            headers: {
                'Content-Type': 'image/png',
                'X-API-Key': api_key
            },
            body: screenshot
        });
        if (!ok) {
            console.warn('@axe-core/watcher: Unable to send screenshot to server');
        }
    })).catch(requestErrorHandler);
};
exports.sendResultsToServer = sendResultsToServer;
exports.default = exports.sendResultsToServer;
//# sourceMappingURL=sendResultsToServer.js.map